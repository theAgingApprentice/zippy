<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>icUnderware: aaEsp32Wroom32v3 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="underwareLogo100x102.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">icUnderware
   </div>
   <div id="projectbrief">Starting point of your next robot&#39;s Integrated Circuit firmware.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classaa_esp32_wroom32v3-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">aaEsp32Wroom32v3 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="aa_esp32_wroom32v3_8h_source.html">aaEsp32Wroom32v3.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3230d7ef8ed66593da272c5b451d9d3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a3230d7ef8ed66593da272c5b451d9d3d">aaEsp32Wroom32v3</a> ()</td></tr>
<tr class="memdesc:a3230d7ef8ed66593da272c5b451d9d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the first constructor form for this class.  <a href="classaa_esp32_wroom32v3.html#a3230d7ef8ed66593da272c5b451d9d3d">More...</a><br /></td></tr>
<tr class="separator:a3230d7ef8ed66593da272c5b451d9d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf77b8f26d6861d1b51d2968ed1ed2e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#aaf77b8f26d6861d1b51d2968ed1ed2e3">aaEsp32Wroom32v3</a> (Print *)</td></tr>
<tr class="separator:aaf77b8f26d6861d1b51d2968ed1ed2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d687caaed488a8dd78157359df9a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a3d8d687caaed488a8dd78157359df9a6">aaEsp32Wroom32v3</a> (int, Print *, bool)</td></tr>
<tr class="separator:a3d8d687caaed488a8dd78157359df9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72942824319ce7fb8ca46a2ea2c05869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a72942824319ce7fb8ca46a2ea2c05869">~aaEsp32Wroom32v3</a> ()</td></tr>
<tr class="memdesc:a72942824319ce7fb8ca46a2ea2c05869"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the destructor for this class.  <a href="classaa_esp32_wroom32v3.html#a72942824319ce7fb8ca46a2ea2c05869">More...</a><br /></td></tr>
<tr class="separator:a72942824319ce7fb8ca46a2ea2c05869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76f966b81728478f84e0990e4e4264e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#ac76f966b81728478f84e0990e4e4264e">logResetReason</a> ()</td></tr>
<tr class="memdesc:ac76f966b81728478f84e0990e4e4264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends human readable reset reason for both cores to the log.  <a href="classaa_esp32_wroom32v3.html#ac76f966b81728478f84e0990e4e4264e">More...</a><br /></td></tr>
<tr class="separator:ac76f966b81728478f84e0990e4e4264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59cf3c88f98076773ff10618365b64c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#ad59cf3c88f98076773ff10618365b64c">logSubsystemDetails</a> ()</td></tr>
<tr class="memdesc:ad59cf3c88f98076773ff10618365b64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends details about the host micro controller to the log.  <a href="classaa_esp32_wroom32v3.html#ad59cf3c88f98076773ff10618365b64c">More...</a><br /></td></tr>
<tr class="separator:ad59cf3c88f98076773ff10618365b64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a731a0ea8c9e9b70c324bd4f1dfaee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a31a731a0ea8c9e9b70c324bd4f1dfaee">getUniqueName</a> (char &amp;, const char *)</td></tr>
<tr class="memdesc:a31a731a0ea8c9e9b70c324bd4f1dfaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a name that is sure to be unique on the network.  <a href="classaa_esp32_wroom32v3.html#a31a731a0ea8c9e9b70c324bd4f1dfaee">More...</a><br /></td></tr>
<tr class="separator:a31a731a0ea8c9e9b70c324bd4f1dfaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619517ccc2162b944d54800fe629fa38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a619517ccc2162b944d54800fe629fa38">areWeConnected</a> ()</td></tr>
<tr class="memdesc:a619517ccc2162b944d54800fe629fa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the status of the wifi connection.  <a href="classaa_esp32_wroom32v3.html#a619517ccc2162b944d54800fe629fa38">More...</a><br /></td></tr>
<tr class="separator:a619517ccc2162b944d54800fe629fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac99aeeabe0d9e3d826fb5a87279d190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#aac99aeeabe0d9e3d826fb5a87279d190">connectWifi</a> ()</td></tr>
<tr class="memdesc:aac99aeeabe0d9e3d826fb5a87279d190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to Wifi.  <a href="classaa_esp32_wroom32v3.html#aac99aeeabe0d9e3d826fb5a87279d190">More...</a><br /></td></tr>
<tr class="separator:aac99aeeabe0d9e3d826fb5a87279d190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8727de83e1985daa8a14e75fe6acf38c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a8727de83e1985daa8a14e75fe6acf38c">rfSignalStrength</a> (int8_t)</td></tr>
<tr class="memdesc:a8727de83e1985daa8a14e75fe6acf38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect an average WiFi signal strength.  <a href="classaa_esp32_wroom32v3.html#a8727de83e1985daa8a14e75fe6acf38c">More...</a><br /></td></tr>
<tr class="separator:a8727de83e1985daa8a14e75fe6acf38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57df622585151000db307fb19eaafd82"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a57df622585151000db307fb19eaafd82">evalSignal</a> (int16_t)</td></tr>
<tr class="memdesc:a57df622585151000db307fb19eaafd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return human readable assessment of signal strength.  <a href="classaa_esp32_wroom32v3.html#a57df622585151000db307fb19eaafd82">More...</a><br /></td></tr>
<tr class="separator:a57df622585151000db307fb19eaafd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285ffae9e67de0015f943292ec1a9ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a3285ffae9e67de0015f943292ec1a9ee">pingIP</a> (IPAddress)</td></tr>
<tr class="memdesc:a3285ffae9e67de0015f943292ec1a9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ping IP address once and return the response.  <a href="classaa_esp32_wroom32v3.html#a3285ffae9e67de0015f943292ec1a9ee">More...</a><br /></td></tr>
<tr class="separator:a3285ffae9e67de0015f943292ec1a9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643cd16bcf5fc9edaa732a01ee790e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a2643cd16bcf5fc9edaa732a01ee790e7">pingIP</a> (IPAddress, int8_t)</td></tr>
<tr class="separator:a2643cd16bcf5fc9edaa732a01ee790e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead07aca0ff66569321c3bf25973bc58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#aead07aca0ff66569321c3bf25973bc58">configure</a> ()</td></tr>
<tr class="memdesc:aead07aca0ff66569321c3bf25973bc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the SOC.  <a href="classaa_esp32_wroom32v3.html#aead07aca0ff66569321c3bf25973bc58">More...</a><br /></td></tr>
<tr class="separator:aead07aca0ff66569321c3bf25973bc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a677c1c3725aa3d800f4f9e75f1d5eb27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a677c1c3725aa3d800f4f9e75f1d5eb27">_transReasonCode</a> (char &amp;, RESET_REASON)</td></tr>
<tr class="memdesc:a677c1c3725aa3d800f4f9e75f1d5eb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a CPU reset reason code to a human readable string.  <a href="classaa_esp32_wroom32v3.html#a677c1c3725aa3d800f4f9e75f1d5eb27">More...</a><br /></td></tr>
<tr class="separator:a677c1c3725aa3d800f4f9e75f1d5eb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79fd606afb457062eb4b64861cf30a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#af79fd606afb457062eb4b64861cf30a8">_transFlashModeCode</a> (char &amp;)</td></tr>
<tr class="memdesc:af79fd606afb457062eb4b64861cf30a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a flash memory mode code to a human readable string.  <a href="classaa_esp32_wroom32v3.html#af79fd606afb457062eb4b64861cf30a8">More...</a><br /></td></tr>
<tr class="separator:af79fd606afb457062eb4b64861cf30a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee692c7075b46a238f1b7046decde97"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a7ee692c7075b46a238f1b7046decde97">_lookForAP</a> ()</td></tr>
<tr class="memdesc:a7ee692c7075b46a238f1b7046decde97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan 2.4GHz radio spectrum for known Access Point.  <a href="classaa_esp32_wroom32v3.html#a7ee692c7075b46a238f1b7046decde97">More...</a><br /></td></tr>
<tr class="separator:a7ee692c7075b46a238f1b7046decde97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc4feafcc3b00499be085d5de9b7c27"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#afbc4feafcc3b00499be085d5de9b7c27">_translateEncryptionType</a> (wifi_auth_mode_t)</td></tr>
<tr class="memdesc:afbc4feafcc3b00499be085d5de9b7c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide human readable Wifi encryption method.  <a href="classaa_esp32_wroom32v3.html#afbc4feafcc3b00499be085d5de9b7c27">More...</a><br /></td></tr>
<tr class="separator:afbc4feafcc3b00499be085d5de9b7c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3c07b7d10a73095094429eb1d4b882"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a2e3c07b7d10a73095094429eb1d4b882">_connectionStatus</a> (wl_status_t)</td></tr>
<tr class="memdesc:a2e3c07b7d10a73095094429eb1d4b882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide human readable text for wifi connection status codes.  <a href="classaa_esp32_wroom32v3.html#a2e3c07b7d10a73095094429eb1d4b882">More...</a><br /></td></tr>
<tr class="separator:a2e3c07b7d10a73095094429eb1d4b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0346ae5c1c64d3aeb91435c9afe9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#ae2b0346ae5c1c64d3aeb91435c9afe9a">_initBluetooth</a> ()</td></tr>
<tr class="memdesc:ae2b0346ae5c1c64d3aeb91435c9afe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Bluetooth system.  <a href="classaa_esp32_wroom32v3.html#ae2b0346ae5c1c64d3aeb91435c9afe9a">More...</a><br /></td></tr>
<tr class="separator:ae2b0346ae5c1c64d3aeb91435c9afe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0ef752d25421ccb809d66441cbe51c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a5c0ef752d25421ccb809d66441cbe51c">_btAddress</a> (char *)</td></tr>
<tr class="memdesc:a5c0ef752d25421ccb809d66441cbe51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Bluetooth.  <a href="classaa_esp32_wroom32v3.html#a5c0ef752d25421ccb809d66441cbe51c">More...</a><br /></td></tr>
<tr class="separator:a5c0ef752d25421ccb809d66441cbe51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8128a680cb7d0791b06bea13e64637b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#ab8128a680cb7d0791b06bea13e64637b">_int32toa</a> (uint32_t, char *)</td></tr>
<tr class="memdesc:ab8128a680cb7d0791b06bea13e64637b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format uint32 number with commas.  <a href="classaa_esp32_wroom32v3.html#ab8128a680cb7d0791b06bea13e64637b">More...</a><br /></td></tr>
<tr class="separator:ab8128a680cb7d0791b06bea13e64637b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a2b637bcc5bad7070f412ff57d360b271"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaa_esp32_wroom32v3.html#a2b637bcc5bad7070f412ff57d360b271">_wiFiEvent</a> (WiFiEvent_t, WiFiEventInfo_t)</td></tr>
<tr class="memdesc:a2b637bcc5bad7070f412ff57d360b271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler for wifi.  <a href="classaa_esp32_wroom32v3.html#a2b637bcc5bad7070f412ff57d360b271">More...</a><br /></td></tr>
<tr class="separator:a2b637bcc5bad7070f412ff57d360b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0171eb2e2a18784677bff9f5559cf854"><td class="memItemLeft" align="right" valign="top"><a id="a0171eb2e2a18784677bff9f5559cf854" name="a0171eb2e2a18784677bff9f5559cf854"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>_unknownAP</b> = &quot;unknown&quot;</td></tr>
<tr class="separator:a0171eb2e2a18784677bff9f5559cf854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0c459735eb92826220bcc98562139f"><td class="memItemLeft" align="right" valign="top"><a id="a2d0c459735eb92826220bcc98562139f" name="a2d0c459735eb92826220bcc98562139f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>_ssid</b></td></tr>
<tr class="separator:a2d0c459735eb92826220bcc98562139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452d3a26a8debbf177510031f3d85dc5"><td class="memItemLeft" align="right" valign="top"><a id="a452d3a26a8debbf177510031f3d85dc5" name="a452d3a26a8debbf177510031f3d85dc5"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>_password</b></td></tr>
<tr class="separator:a452d3a26a8debbf177510031f3d85dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9889bca5a5f51a4ef21788c0b2cc1723"><td class="memItemLeft" align="right" valign="top"><a id="a9889bca5a5f51a4ef21788c0b2cc1723" name="a9889bca5a5f51a4ef21788c0b2cc1723"></a>
<a class="el" href="classaa_format.html">aaFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_convert</b></td></tr>
<tr class="separator:a9889bca5a5f51a4ef21788c0b2cc1723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecca1de3a95a800571fdc75dfb2b5741"><td class="memItemLeft" align="right" valign="top"><a id="aecca1de3a95a800571fdc75dfb2b5741" name="aecca1de3a95a800571fdc75dfb2b5741"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_SSIDIndex</b> = 0</td></tr>
<tr class="separator:aecca1de3a95a800571fdc75dfb2b5741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ec77f2cbf8c59dff8cb0bffb46296b"><td class="memItemLeft" align="right" valign="top"><a id="a92ec77f2cbf8c59dff8cb0bffb46296b" name="a92ec77f2cbf8c59dff8cb0bffb46296b"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>_uniqueName</b> [HOST_NAME_SIZE]</td></tr>
<tr class="separator:a92ec77f2cbf8c59dff8cb0bffb46296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bc45cac45b3cafce1827615d8574f1"><td class="memItemLeft" align="right" valign="top"><a id="a58bc45cac45b3cafce1827615d8574f1" name="a58bc45cac45b3cafce1827615d8574f1"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>_uniqueNamePtr</b> = &amp;_uniqueName[0]</td></tr>
<tr class="separator:a58bc45cac45b3cafce1827615d8574f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b1dde2a9425d77b481f1f623eb490a"><td class="memItemLeft" align="right" valign="top"><a id="a83b1dde2a9425d77b481f1f623eb490a" name="a83b1dde2a9425d77b481f1f623eb490a"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>_HOST_NAME_PREFIX</b></td></tr>
<tr class="separator:a83b1dde2a9425d77b481f1f623eb490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The <a class="el" href="classaa_esp32_wroom32v3.html">aaEsp32Wroom32v3</a> class provides a single object of authority regarding the ESP32Wroom32 version 3 SOC. Details are collected from both FreeRTOS and the ESP32 Arduino framework.</p>
<p >The EP32 is based on a Harvard architecture meaning that there are two physically separate paths (buses) to access SRAM. The first bus is used for accessing Instruction Memory (IRAM). IRAM is used for code execution and text data. It contains:</p><ul>
<li>32KB cache for CPU0</li>
<li>32KB cache for CPU1</li>
<li>Interrupt vectors</li>
<li>Text (code binary)</li>
<li>Free IRAM added to the heap</li>
</ul>
<p >The second bus is used for accessing Data Memory (DRAM). DRAM handles Block Started by Symbol (BSS) aka the stack, data aka static data and heap aka the heap. The Memory Mapping Unit (MMU) takes the total SRAM and maps it to distinct address locations. These locations are called Static Data, the Heap and the Stack.</p>
<p >The ESP32 chip's architecture consists of five subsystems.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
The Core subsystem</h1>
<p >The ESP32_WROOM_32E core subsystem is comprised of two CPU(s), RAM and ROM.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
The Core CPUs</h2>
<p >The CPUs are Xtensa 32-bit LX6 microprocessors known as core 0 and core 1. Core0 is used for RF communication. The Arduino binary runs on core 1 by default though you can pin threads to core 0 in order to run code there.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
The Core memory</h2>
<p >The Core memory comes as both ROM (Read Only Memory) and SRAM (Static Random Access Memory). The ROM contains espressif magic and we cannot play with that so instead we focus on the SRAM.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
SRAM</h3>
<p >The internal Core RAM is divided into three memory blocks called SRAM0 (192KB), SRAM1 (128 KB) and SRAM2 (200 KB). SRAM0 and SRAM1 can be used as a contiguous IRAM whereas SRAM1 and SRAM2 can be used as a contiguous DRAM address space. While SRAM1 can be used as both IRAM and DRAM, for practical purposes the Espressif IoT Development Framework (ESP-IDF) uses SRAM1 as DRAM, as it’s generally the data memory that applications fall short of.</p>
<p >The 192 KB of available IRAM in ESP32 is used for code execution, as well as part of it is used as a cache memory for flash (and PSRAM) access.</p>
<ol type="1">
<li>First 32KB IRAM is used as a CPU0 cache. This is statically configured in the hardware and can’t be changed.</li>
<li>The next 32KB is used as CPU1 cache memory. This is statically configured in the hardware and can’t be changed.</li>
<li>After the first 64KB, the linker script starts placing the text region in IRAM. It first places all the interrupt vectors and then all the text in the compiled application that is marked to be placed in IRAM. While in common case, majority of the application is executed out of the flash (XiP), there are some portions of the applications which are time critical, or that operate on flash itself. They need to be placed in IRAM and that is achieved using a special attribute to these functions or files and linker script doing a job of placing them in IRAM. The symbols _iram_text_start and _iram_text_end are placed by the linker script at the two boundaries of this text section.</li>
<li>The IRAM after the text section remains unused and is added to the heap.</li>
</ol>
<p >_iram_text_start and _iram_text_end symbols are placed by the linker script at the two boundaries of this text section. The IRAM after the text section remains unused and is added to the heap. Also, when the application is configured in a single-core mode, the CPU1 is not functional and CPU1 cache is unused. In that case, CPU1 cache memory (0x40078000–0x4007FFFF ) is added to the heap. The unused IRAM, that is placed in the heap, can be accessed through dynamic allocations. It can be used to place any code in IRAM if the application has such a requirement. However this is quite uncommon.</p>
<p >The IRAM can also be used for data, but with two important limitations.</p><ol type="1">
<li>The address used for access to the data in IRAM has to be 32-bit aligned.</li>
<li>The size of data accessed too has to be 32-bit aligned.</li>
</ol>
<p >If the application has such data that can obey these two rules of accesses, it can make use of IRAM memory for that data.</p>
<ul>
<li>A typical (simplified) DRAM layout for an application. As the DRAM addresses start at the end of SRAM2, increasing in backward direction, the link time segments allocation happens starting at the end of SRAM2.</li>
</ul>
<p >The first 8KB (0x3FFA_E000–0x3FFA_FFFF) are used as a data memory for some of the ROM functions.</p><ol type="1">
<li>The linker then places initialised data segment after this first 8KB memory.</li>
<li>Zero initialised BSS segment (the stack) comes next. The memory remaining after allocating static data and BSS segments (the stack), is configured to be used as a heap. This is where typical dynamic memory allocations go.</li>
</ol>
<p >Please note that the size of data and BSS segments (the stack) depend on the application. So each application, based on the components that it uses and APIs it calls has a different available heap size to begin with.</p>
<p >There are two regions within the heap (0x3FFE_0000–0x3FFE_0440 — 1088 bytes) and (0x3FFE_3F20–0x3FFE_4350–1072 bytes) that are used by ROM code for its data. These regions are marked reserved and the heap allocator does not allocate memory from these regions.</p>
<p >Static Data segment is a block of reserved space in SRAM for all the global and static variables from your program. For variables with initial values, the runtime system copies the initial value from Flash when the program starts.</p>
<p >The heap segment is for dynamically allocated data items. The heap grows from the top of the static data area up as data items are allocated.</p>
<p >The stack (BSS segment) is used for local variables and for maintaining a record of interrupts and function calls. The stack grows from the top of memory down towards the heap. Every interrupt, function call and/or local variable allocation causes the stack to grow. Returning from an interrupt or function call will reclaim all stack space used by that interrupt or function. See more at <a href="https://blog.espressif.com/esp32-programmers-memory-model-259444d89387">this link</a>.</p>
<div class="fragment"><div class="line">NOTE: Most memory problems occur when the stack and the heap collide. When </div>
<div class="line"><span class="keyword">this</span> happens, one or both of these memory areas will be corrupted with </div>
<div class="line">unpredictable results. In some cases it will cause an immediate crash. In </div>
<div class="line">others, the effects of the corruption may not be noticed until much later.</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
The Wireless subsystem</h1>
<p >The Wireless subsystem is comprised of WiFi and Bluetooth which share the following common components:</p>
<ol type="1">
<li>An RF reciever,</li>
<li>An RF transmitter,</li>
<li>A clock generator,</li>
<li>A switch, and</li>
<li>A Balun. <br  />
</li>
</ol>
<p >The WiFi standards supported are 802.11 b/g/n/e/i (802.11n @ 2.4 GHz up to 150 Mbit/s). The Bluetooth standards supported is v4.2 BR/EDR and Bluetooth Low Energy (BLE).</p>
<h2><a class="anchor" id="autotoc_md9"></a>
The RTC</h2>
<p >The Real Time Clock (RTC) is comprised of three things:</p><ol type="1">
<li>The Phasor measurement unit (PMU),</li>
<li>An Ultra Low Power (ULP) 32-bit co-processor, and</li>
<li>Recovery memory.</li>
</ol>
<p >The Real Time Clock (RTC) is a minimally viable very low power system that remains active even when the ESP32 is in hybernation or standby mode. It is comprised of a Phasor Measurement Unit (PMU), a small ultra low power (ULP) 32-bit co-processor, and 8Kbs of RAM memory known as the recovery memory. <br  />
</p>
<p >RTC is able to access some SRAM as well as some GPIO pins (the ones with capacitive touch capabilities) even when the chip is in non active modes.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
The ULP coprocessor</h3>
<p >The Ultra Low Power (ULP) coprocessor is a simple Finite State Machine (FSM) which is designed to perform measurements using the ADC, temperature sensor, and external I2C sensors, while the main processors are in deep sleep mode. The ULP coprocessor can access the RTC_SLOW_MEM memory region, and registers in RTC_CNTL, RTC_IO, and SARADC peripherals. The ULP coprocessor uses fixed-width 32-bit instructions, 32-bit memory addressing, and has 4 general-purpose 16-bit registers.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Recovery memory</h3>
<p >The RTC memory is 8Kbs of RAM known as the recovery memory. The recovery RAM is area of SRAM which remains powered and accessible to the RTC functions of the ESP32 microcontroller and the ULP coprocessor even when standby is activated.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
The PMU</h3>
<p >The Phasor measurement unit (PMU) monitors for system events which will wake up the ESP32 when required.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
The Crytographic Acceleration subsystem</h1>
<p >The crytographic hardware acceleration subsystem supports four hardware acceleration algorithms:</p><ol type="1">
<li>SHA,</li>
<li>RSA,</li>
<li>AES, and</li>
<li>RNG. <br  />
</li>
</ol>
<h1><a class="anchor" id="autotoc_md14"></a>
The Peripherals subsystem</h1>
<p >The Peripherals subsystem covers external devices on either the SPI or I2C bus as well as all of the General Purpose Input/Output (GPIO) pins. Off-chip SPI memory can be mapped into the available address space as external memory. Parts of the embedded memory can be used as transparent cache for this external memory.</p>
<ol type="1">
<li>Supports up to 16 MB off-Chip SPI Flash.</li>
<li>Supports up to 8 MB off-Chip SPI SRAM.</li>
</ol>
<h2><a class="anchor" id="autotoc_md15"></a>
Off-chip Flash memory</h2>
<p >Flash memory is used to store your program image and any initialized data. You can execute program code from flash, but you can't modify data in flash memory from your executing code. To modify the data, it must first be copied into SRAM. Flash memory is the same technology used for thumb-drives and SD cards. It is non-volatile, so your program will still be there when the system is powered off. Flash memory has a finite lifetime of about 100,000 write cycles. So if you upload 10 programs a day, every day for the next 27 years, you might wear it out. The Huzzah32 featherboard does not come with any off-chip Flash memory.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Off-chip PSRAM memory</h2>
<p >Off-chip SPI memory can be mapped into the available address space as external memory. Parts of the embedded memory can be used as transparent cache for this external memory. The architecture can supports up to 8 MB off-chip SPI SRAM (PSRAM). The Huzzah32 featherboard does not come with any PSRAM. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3230d7ef8ed66593da272c5b451d9d3d" name="a3230d7ef8ed66593da272c5b451d9d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3230d7ef8ed66593da272c5b451d9d3d">&#9670;&nbsp;</a></span>aaEsp32Wroom32v3() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">aaEsp32Wroom32v3::aaEsp32Wroom32v3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the first constructor form for this class. </p>
<p >Instantiating this class using the first form results in the following default settings.</p>
<ol type="1">
<li><a class="el" href="class_logging.html">Logging</a> level = Silent. This means that this class will not send messages to the log.</li>
<li><a class="el" href="class_logging.html">Logging</a> output goes to the standard Serial interface.</li>
<li>Show <a class="el" href="class_logging.html">Logging</a> level = TRUE. This prefixes a single letter to each log <br  />
 message that indicates the method used to issue it (e.g. Log.verbose() messages show up in the logs with a V prepended to them). <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="aaf77b8f26d6861d1b51d2968ed1ed2e3" name="aaf77b8f26d6861d1b51d2968ed1ed2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf77b8f26d6861d1b51d2968ed1ed2e3">&#9670;&nbsp;</a></span>aaEsp32Wroom32v3() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">aaEsp32Wroom32v3::aaEsp32Wroom32v3 </td>
          <td>(</td>
          <td class="paramtype">Print *&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p >Instantiating this class using the second form results in the following default settings.</p>
<ol type="1">
<li><a class="el" href="class_logging.html">Logging</a> level = Silent. This means that this class will not send messages to the log.</li>
<li><a class="el" href="class_logging.html">Logging</a> output goes wherever you specified with the output parameter.</li>
<li>Show <a class="el" href="class_logging.html">Logging</a> level = TRUE. This prefixes a single letter to each log <br  />
 message that indicates the method used to issue it (e.g. Log.verbose() messages show up in the logs with a V prepended to them). <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>class that handles bit stream input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a3d8d687caaed488a8dd78157359df9a6" name="a3d8d687caaed488a8dd78157359df9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d687caaed488a8dd78157359df9a6">&#9670;&nbsp;</a></span>aaEsp32Wroom32v3() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">aaEsp32Wroom32v3::aaEsp32Wroom32v3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>loggingLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Print *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p >Instantiating this class using the third form results in you controlling all <a class="el" href="class_logging.html">Logging</a> behavior for this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loggingLevel</td><td>is one of 6 predefined levels from the <a class="el" href="class_logging.html">Logging</a> library. </td></tr>
    <tr><td class="paramname">output</td><td>is a class that can handle bit stream input (e.g. Serial). </td></tr>
    <tr><td class="paramname">showLevel</td><td>prefixs log message with the <a class="el" href="class_logging.html">Logging</a> level letter when TRUE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a id="a72942824319ce7fb8ca46a2ea2c05869" name="a72942824319ce7fb8ca46a2ea2c05869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72942824319ce7fb8ca46a2ea2c05869">&#9670;&nbsp;</a></span>~aaEsp32Wroom32v3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">aaEsp32Wroom32v3::~aaEsp32Wroom32v3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the destructor for this class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5c0ef752d25421ccb809d66441cbe51c" name="a5c0ef752d25421ccb809d66441cbe51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0ef752d25421ccb809d66441cbe51c">&#9670;&nbsp;</a></span>_btAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::_btAddress </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>targetArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize Bluetooth. </p>
<p >The Bluetooth address consists of six integers. In this function we concatinate these 6 integers as two-digit hex char* values separate by an additional 1 colon character. This results in a 15 character long address in a character array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>

</div>
</div>
<a id="a2e3c07b7d10a73095094429eb1d4b882" name="a2e3c07b7d10a73095094429eb1d4b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3c07b7d10a73095094429eb1d4b882">&#9670;&nbsp;</a></span>_connectionStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * aaEsp32Wroom32v3::_connectionStatus </td>
          <td>(</td>
          <td class="paramtype">wl_status_t&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide human readable text for wifi connection status codes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wl_status_t</td><td>wifi connection status code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true when connected, false when any other status. </dd></dl>

</div>
</div>
<a id="ae2b0346ae5c1c64d3aeb91435c9afe9a" name="ae2b0346ae5c1c64d3aeb91435c9afe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0346ae5c1c64d3aeb91435c9afe9a">&#9670;&nbsp;</a></span>_initBluetooth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool aaEsp32Wroom32v3::_initBluetooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize Bluetooth system. </p>
<p >Initializing the Bluetooth system involves the following 3 steps:</p><ol type="1">
<li>Initialize the contrller.</li>
<li>Initialize Bluedroid.</li>
<li>Enable Bluedroid.</li>
</ol>
<h1><a class="anchor" id="autotoc_md0"></a>
Esp32 Bluetooth Architecture</h1>
<p >Bluetooth is a wireless technology standard for exchanging data over short distances, with advantages including robustness, low power consumption and low cost. The Bluetooth system can be divided into two different categories: Classic Bluetooth and Bluetooth Low Energy (BLE). ESP32 supports dual-mode Bluetooth, meaning that both Classic Bluetooth and BLE are supported by ESP32. Basically, the Bluetooth protocol stack is split into two parts: a “controller stack” and a “host stack”. The controller stack contains the PHY, Baseband, Link Controller, Link Manager, Device Manager, HCI and other modules, and is used for the hardware interface management and link management. The host stack contains L2CAP, SMP, SDP, ATT, GATT, GAP and various profiles, and functions as an interface to the application layer, thus facilitating the application layer to access the Bluetooth system. The Bluetooth Host can be implemented on the same device as the Controller, or on different devices. Both approaches are supported by ESP32.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Bluedroid</h1>
<p >The BLUEDROID Bluetooth Stack communicates with Bluetooth Controller over VHCI (Virtual Host Controller Interface) and at the same time provides APIs for user application. Bluetooth Profiles determine the functions of each layer of the Bluetooth from PHY to L2CAP while the Bluetooth Protocols define message formats and procedures for data transport, link control etc.</p>
<p >The following is a list of Classic Bluetooth Profiles and Protocols supported by BLUEDROID Bluetooth Stack of ESP32.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Classic Bluetooth Profiles</h2>
<ol type="1">
<li>GAP</li>
<li>A2DP (SNK)</li>
<li>AVRCP (CT)</li>
</ol>
<h2><a class="anchor" id="autotoc_md3"></a>
Classic Bluetooth Protocols</h2>
<p >L2CAP SDP AVDTP AVCTP</p>
<p >The communication between ESP32’s Processor and Bluetooth Controller is based on Serial Interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>

</div>
</div>
<a id="ab8128a680cb7d0791b06bea13e64637b" name="ab8128a680cb7d0791b06bea13e64637b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8128a680cb7d0791b06bea13e64637b">&#9670;&nbsp;</a></span>_int32toa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * aaEsp32Wroom32v3::_int32toa </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>startBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format uint32 number with commas. </p>
<p >Format a uint32_t (32 bits) number into a string in the format "23,854,972". The provided buffer must be at least 14 bytes long. The number will be right-adjusted in the buffer. Returns a pointer to the first digit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the number to be convereted. </td></tr>
    <tr><td class="paramname">startBuffer</td><td>is a pointer to the start of the conversion buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to first digit. </dd></dl>

</div>
</div>
<a id="a7ee692c7075b46a238f1b7046decde97" name="a7ee692c7075b46a238f1b7046decde97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee692c7075b46a238f1b7046decde97">&#9670;&nbsp;</a></span>_lookForAP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * aaEsp32Wroom32v3::_lookForAP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan 2.4GHz radio spectrum for known Access Point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* Service Set IDentifier (SSID). </dd></dl>

</div>
</div>
<a id="af79fd606afb457062eb4b64861cf30a8" name="af79fd606afb457062eb4b64861cf30a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79fd606afb457062eb4b64861cf30a8">&#9670;&nbsp;</a></span>_transFlashModeCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::_transFlashModeCode </td>
          <td>(</td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>details</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a flash memory mode code to a human readable string. </p>
<p >The ESP32 MCU supports the following FLASH memory modes: 0. FM_QIO - SPI host uses the "Quad I/O Fast Read" command (EBh). Four SPI pins are used to write the flash address part of the command, and to read flash data out. Therefore these phases need a quarter the clock cycles compared to standard SPI.</p><ol type="1">
<li>FM_QOUT - SPI host uses the "Quad Output Fast Read" command (6Bh). Four SPI pins are used to read the flash data out. Slightly slower than QIO, because the address is written via the single MOSI data pin.</li>
<li>FM_DIO - SPI host uses the "Dual I/O Fast Read" command (BBh). Two SPI pins are used to write the flash address part of the command, and to read flash data out. Therefore these phases need half the clock cycles compared to standard SPI.</li>
<li>FM_DOUT - SPI host uses the "Dual Output Fast Read" command (3Bh). Two SPI pins are used to read flash data out. Slightly slower than DIO, because the address is written via the single MOSI data pin.</li>
<li>FM_FAST_READ - Have not found definition.</li>
<li>FM_SLOW_READ - Have not found definition.</li>
<li>FM_UNKNOWN - Unknown mode. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="afbc4feafcc3b00499be085d5de9b7c27" name="afbc4feafcc3b00499be085d5de9b7c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc4feafcc3b00499be085d5de9b7c27">&#9670;&nbsp;</a></span>_translateEncryptionType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * aaEsp32Wroom32v3::_translateEncryptionType </td>
          <td>(</td>
          <td class="paramtype">wifi_auth_mode_t&#160;</td>
          <td class="paramname"><em>encryptionType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide human readable Wifi encryption method. </p>
<p >Wifi encryptions options are:</p><ol type="1">
<li>OPEN</li>
<li>WEP</li>
<li>WPA_PSK</li>
<li>WPA2_PSK</li>
<li>WPA_WPA2_PSK</li>
<li>WPA2_ENTERPRISE <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wifi_auth_mode_t</td><td>Wifi encryption type code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* Encryption type in one word. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a677c1c3725aa3d800f4f9e75f1d5eb27" name="a677c1c3725aa3d800f4f9e75f1d5eb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677c1c3725aa3d800f4f9e75f1d5eb27">&#9670;&nbsp;</a></span>_transReasonCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::_transReasonCode </td>
          <td>(</td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RESET_REASON&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a CPU reset reason code to a human readable string. </p>
<p >This class populates &amp;reason with text that is accesible to the calling code. These codes are as follows:</p>
<ol type="1">
<li>POWERON_RESET. Vbat power on reset.</li>
<li>SW_RESET. Software reset digital core.</li>
<li>OWDT_RESET. Legacy watch dog reset digital core.</li>
<li>DEEPSLEEP_RESET. Deep Sleep reset digital core.</li>
<li>SDIO_RESET. Reset by SLC module, reset digital core.</li>
<li>TG0WDT_SYS_RESET. Timer Group0 Watch dog reset digital core.</li>
<li>TG1WDT_SYS_RESET. Timer Group1 Watch dog reset digital core.</li>
<li>RTCWDT_SYS_RESET. RTC Watch dog Reset digital core.</li>
<li>INTRUSION_RESET. Instrusion tested to reset CPU.</li>
<li>TGWDT_CPU_RESET. Time Group reset CPU.</li>
<li>SW_CPU_RESET. Software reset CPU.</li>
<li>RTCWDT_CPU_RESET. RTC Watch dog Reset CPU.</li>
<li>EXT_CPU_RESET. For APP CPU, reset by PRO CPU.</li>
<li>RTCWDT_BROWN_OUT_RESET. Reset when the vdd voltage is not stable.</li>
<li>RTCWDT_RTC_RESET. RTC Watch dog reset digital core and rtc module.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>is the address to put the reason code. </td></tr>
    <tr><td class="paramname">code</td><td>is the nuerica reset value reported by the CPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>

</div>
</div>
<a id="a2b637bcc5bad7070f412ff57d360b271" name="a2b637bcc5bad7070f412ff57d360b271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b637bcc5bad7070f412ff57d360b271">&#9670;&nbsp;</a></span>_wiFiEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::_wiFiEvent </td>
          <td>(</td>
          <td class="paramtype">WiFiEvent_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WiFiEventInfo_t&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event handler for wifi. </p>
<p >Tracks all wifi event activity even though we do not act on any of it at this time. At the very least the logs help us trouble shoot wifi issues but this routine also acts as a reminder of what functional possibilities exist for future consideration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WiFiEvent_t</td><td>Type of event that triggered this handler. </td></tr>
    <tr><td class="paramname">WiFiEventInfo_t</td><td>Additional information about the triggering event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a619517ccc2162b944d54800fe629fa38" name="a619517ccc2162b944d54800fe629fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619517ccc2162b944d54800fe629fa38">&#9670;&nbsp;</a></span>areWeConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool aaEsp32Wroom32v3::areWeConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report the status of the wifi connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true when connected, false when any other status. </dd></dl>

</div>
</div>
<a id="aead07aca0ff66569321c3bf25973bc58" name="aead07aca0ff66569321c3bf25973bc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead07aca0ff66569321c3bf25973bc58">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool aaEsp32Wroom32v3::configure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the SOC. </p>
<p >Set up the SOC based on the configuration structure passed by reference. <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wl_status_t</td><td>wifi connection status code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true when connected, false when any other status. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>#43 Create config structure and pass a pointer to it during configuration.</dd></dl>

</div>
</div>
<a id="aac99aeeabe0d9e3d826fb5a87279d190" name="aac99aeeabe0d9e3d826fb5a87279d190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac99aeeabe0d9e3d826fb5a87279d190">&#9670;&nbsp;</a></span>connectWifi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::connectWifi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to Wifi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>

</div>
</div>
<a id="a57df622585151000db307fb19eaafd82" name="a57df622585151000db307fb19eaafd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57df622585151000db307fb19eaafd82">&#9670;&nbsp;</a></span>evalSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * aaEsp32Wroom32v3::evalSignal </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>signalStrength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return human readable assessment of signal strength. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int16_t</td><td>Signal strength as measured in decibels (db). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char* Assessment of signal quality in one or two words. </dd></dl>

</div>
</div>
<a id="a31a731a0ea8c9e9b70c324bd4f1dfaee" name="a31a731a0ea8c9e9b70c324bd4f1dfaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a731a0ea8c9e9b70c324bd4f1dfaee">&#9670;&nbsp;</a></span>getUniqueName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::getUniqueName </td>
          <td>(</td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>targetArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a name that is sure to be unique on the network. </p>
<p >Tis function concatintes a prefix defined in the main program with the MAC address of the SOC creating a unique name to be used for network related activities such as prefixing MQTT broker topic names etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetArray</td><td>address of char array into which we place the name. </td></tr>
    <tr><td class="paramname">prefix</td><td>Characters that make up the first half of the name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>

</div>
</div>
<a id="ac76f966b81728478f84e0990e4e4264e" name="ac76f966b81728478f84e0990e4e4264e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76f966b81728478f84e0990e4e4264e">&#9670;&nbsp;</a></span>logResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::logResetReason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends human readable reset reason for both cores to the log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>

</div>
</div>
<a id="ad59cf3c88f98076773ff10618365b64c" name="ad59cf3c88f98076773ff10618365b64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59cf3c88f98076773ff10618365b64c">&#9670;&nbsp;</a></span>logSubsystemDetails()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aaEsp32Wroom32v3::logSubsystemDetails </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends details about the host micro controller to the log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null. </dd></dl>

</div>
</div>
<a id="a3285ffae9e67de0015f943292ec1a9ee" name="a3285ffae9e67de0015f943292ec1a9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3285ffae9e67de0015f943292ec1a9ee">&#9670;&nbsp;</a></span>pingIP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool aaEsp32Wroom32v3::pingIP </td>
          <td>(</td>
          <td class="paramtype">IPAddress&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ping IP address once and return the response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IPAddress</td><td>Address to ping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Result of ping. </dd></dl>

</div>
</div>
<a id="a2643cd16bcf5fc9edaa732a01ee790e7" name="a2643cd16bcf5fc9edaa732a01ee790e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2643cd16bcf5fc9edaa732a01ee790e7">&#9670;&nbsp;</a></span>pingIP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool aaEsp32Wroom32v3::pingIP </td>
          <td>(</td>
          <td class="paramtype">IPAddress&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>numPings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IPAddress</td><td>Address to ping. </td></tr>
    <tr><td class="paramname">int8_t</td><td>Number of times to ping address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Result of pings. </dd></dl>

</div>
</div>
<a id="a8727de83e1985daa8a14e75fe6acf38c" name="a8727de83e1985daa8a14e75fe6acf38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8727de83e1985daa8a14e75fe6acf38c">&#9670;&nbsp;</a></span>rfSignalStrength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long aaEsp32Wroom32v3::rfSignalStrength </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>dataPoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect an average WiFi signal strength. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int8_t</td><td>Number of datapoints to use to create average. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long Average signal strength of AP connection in decibels (db). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/aaEsp32Wroom32v3/<a class="el" href="aa_esp32_wroom32v3_8h_source.html">aaEsp32Wroom32v3.h</a></li>
<li>lib/aaEsp32Wroom32v3/aaEsp32Wroom32v3.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
